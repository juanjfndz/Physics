from manim import *
import numpy as np

#------------------------------------------------------------------------------
# 0th Part
#------------------------------------------------------------------------------

class DistanceAction(Scene):
    """
    Introduces the concept of distance action versus fields.
    """
    def construct(self):
        # Define the equations
        title = Tex("Distance Action").to_edge(UP * 5)
        equations = MathTex(
            r"F_{G}(\mathbf{r}) = G\frac{m_{1}m_{2}}{r^{2}},\hspace{5mm} F_{E}(\mathbf{r}) = \frac{1}{4\pi\epsilon}\frac{q_{1}q_{2}}{r^{2}}"
        ).to_edge(UP * 7)

        # Add the equations to the scene
        self.play(FadeIn(equations))
        self.wait(2)
        self.play(Write(title))

#------------------------------------------------------------------------------
# 1st Part
#------------------------------------------------------------------------------

class NewtonCriticScene(Scene):
    """
    Discusses Newton's theory of gravity and criticisms of his concept of distance action.
    """
    def construct(self):
        """
        Sources:
            - http://strangebeautiful.com/other-texts/newton-papers-letter-nat-phil-cohen-ed.pdf
            - https://plato.stanford.edu/archives/win2008/entries/qm-action-distance/#ActDisCoExiNonSepHol
        """
        # Define text
        text1 = Text(
            "(...) That Gravity should be innate, inherent and essential to Matter, \n"
            "so that one body may act upon another at a distance thro' a Vacuum, (...), \n"
            "is to me so great an Absurdity (...)",
            color=BLUE
        ).scale(0.5).shift(UP)
        text2 = Text("Gravity must be caused by an Agent acting constantly according to certain laws.", color=RED).scale(0.6).next_to(text1, DOWN)
        text3 = Text("- Isaac Newton, Letters to Bentley, 1692", color=BLUE).scale(0.4).next_to(text2, DOWN)
        
        # Add text to the scene
        self.play(Write(text1), Write(text2))
        self.play(Write(text3))

#------------------------------------------------------------------------------
# 2nd Part
#------------------------------------------------------------------------------

def magnetic_field(pos):
    """
    Generates the magnetic field lines. 
    
    Parameters:
        pos (tuple): The position in 2D space. 
        
    Returns:
        tuple: The magnetic field vector at the given position, in Cartesian coordinates. 
        
    References:
        https://docs.manim.org.cn/documentation/mobject/vector_field.html
    """
    x, y = pos[0], pos[1]
    r    = np.sqrt(x**2 + y**2)
    
    if r <= 1: # Inside the sphere causes problems. 
        return (0, 0)
    
    else:
        # Convert to polar coordinates
        theta = np.arctan2(y, x)
        
        fac = -5 * r**(-3)
        Br, Btheta = fac * np.cos(theta), fac * np.sin(theta)
        
        # Transform to Cartesian coordinates. Note: make North point up, not to the right. 
        c, s = np.cos(np.pi/2 + theta), np.sin(np.pi/2 + theta)
        
        Bx = -Btheta * s + Br * c
        By =  Btheta * c + Br * s
        return (Bx, By)
    

class MagneticFieldScene(Scene):
    def construct(self):
        """
        Shows the magnetic field generated by a source in 2D space.
        """
        def to_manim_coords(pos):
            """
            Converts Cartesian coordinates to manim coordinates.
            
            Parameters:
                pos (tuple): The position in 2D space in Cartesian coordinates.
                
            Returns:
                np.ndarray: The position in manim coordinates in manim's coordinate system.
            """
            result = magnetic_field(pos)
            return np.array([result[0], result[1], 0])
        
        # Objects
        source_circle = Circle(radius=0.5, color=BLUE, fill_opacity=1)   
        
        stream_lines  = StreamLines(to_manim_coords, 
                                    stroke_width=3, 
                                    virtual_time=1,
                                    max_anchors_per_line=50)

        vector_field  = ArrowVectorField(to_manim_coords, 
                                         x_range=[-7, 7, 0.5], 
                                         y_range=[-4, 4, 0.5])
        

        # Scene
        self.play(FadeIn(source_circle))
        self.wait(2)
        
        self.play(stream_lines.create())
        self.wait(4)
        
        self.play(FadeOut(stream_lines), DrawBorderThenFill(vector_field))

        
#------------------------------------------------------------------------------
# 3rd Part
#------------------------------------------------------------------------------

class RetardedPotential(Scene):
    def construct(self):
        # Define the equations
        text1 = Tex("Electromagnetic potentials").to_edge(UP*3)
        eq1 = MathTex(r"\phi(\mathbf{r}, t)= \frac{1}{4\pi\varepsilon_0} \int\frac{\rho_{c}(\mathbf{r'}, t-\frac{|\mathbf{r}-\mathbf{r'}|}{c} )}{|\mathbf{r}-\mathbf{r'}|}d^3r'")
        eq1[0][0].set_color(BLUE)
        eq1[0][4].set_color(YELLOW)
        eq1[0][14:16].set_color(BLUE)
        eq1[0][20:30].set_color(YELLOW)
        
        eq2 = MathTex(r"\mathbf{A}(\mathbf{r},t)=\frac{\mu_0}{4\pi}\int\frac{\mathbf{J}(\mathbf{r'},t-\frac{|\mathbf{r}-\mathbf{r'}|}{c})}{|\mathbf{r}-\mathbf{r'}|}d^3r'")
        eq2[0][0].set_color(BLUE)
        eq2[0][4].set_color(YELLOW)
        eq2[0][13].set_color(BLUE)
        eq2[0][18:28].set_color(YELLOW)
        
        text2 = Tex("Gravitational potential").to_edge(DOWN*5)
        eq3 = MathTex(r"\Phi(\mathbf{r}, t)=-4\pi G_{N}\int\frac{\rho_{m}(\mathbf{r'}, t)}{|\mathbf{r}-\mathbf{r'}|}d^3r'")
        eq3[0][0].set_color(BLUE)
        eq3[0][4].set_color(YELLOW)
        eq3[0][13:15].set_color(BLUE)
        eq3[0][19].set_color(YELLOW)
        
        # Position the equations on the screen
        eq1.next_to(text1, DOWN)
        eq2.next_to(eq1, DOWN)
        eq3.next_to(text2, DOWN)

        # Add the equations to the scene
        self.play(Write(text1), FadeIn(eq1), FadeIn(eq2))

        self.wait(2)
        
        # Use animate to create a smooth transition between positions
        # and use add to add the new objects to the scene
        self.play(
            text1.animate.to_edge(UP*1.5), # animate changes in position
            eq1.animate.to_edge(UP*3),   # animate changes in position
            eq2.animate.to_edge(UP*6),   # animate changes in position
            FadeIn(text2),                 # animate fadein
            FadeIn(eq3)                    # animate fadein
        ) 

#------------------------------------------------------------------------------
# 4th Part
#------------------------------------------------------------------------------

class SRScene(ThreeDScene):
    def func(self, u, v):
        return np.array([v, u, 0])
    
    def curvfunc(self, u, v):
        return np.array([v, u, -3*np.exp(-1/5*(u**2 + v**2))])
    
    def construct(self):
        
        prompt1 = Tex("Special Relativity").to_corner(UP + LEFT)
        prompt2 = MathTex(r"c = 299{.}792{.}458 \, \text{m/s}").next_to(prompt1, DOWN) # Add commas to the number
        
        self.add_fixed_in_frame_mobjects(prompt1)
        self.add_fixed_in_frame_mobjects(prompt2)
        
        axes = ThreeDAxes(z_range=(-4, 4, 1)) # Remove the extra space before and after the tuple
        cone1 = Cone(direction=X_AXIS+Y_AXIS+100*Z_AXIS, resolution=8, fill_color=YELLOW)
        cone2 = Cone(direction=-(X_AXIS+Y_AXIS+100*Z_AXIS), resolution=8, fill_color=YELLOW)
        surface = Surface(
            lambda u, v: axes.c2p(*self.func(u, v)),
            u_range=(-PI, PI), # Use parentheses instead of brackets for tuples
            v_range=(-TAU, TAU),
            resolution=16,
            fill_opacity=0.4
        )
        
        self.set_camera_orientation(phi=5*PI/11, theta=PI/9)
        self.add(axes, cone1, cone2, surface)
        
        
        # add camera rotation animation
        self.begin_ambient_camera_rotation(rate=0.1)
        self.play(Write(prompt1), FadeIn(prompt2))
        self.wait(5)
        self.stop_ambient_camera_rotation()
        
        
        # add curved surface animation and changing cone
        
        curved_surface = Surface(
            lambda u, v: axes.c2p(*self.curvfunc(u, v)),
            u_range=(-PI, PI), # Use parentheses instead of brackets for tuples
            v_range=(-TAU, TAU),
            resolution=8,
            fill_opacity=0.6
        )
        
        sphere = Sphere(
            center=(0, 0, 1),
            radius=1,
            resolution=(10, 10),
            u_range=(0.001, PI - 0.001), # Use parentheses instead of brackets for tuples
            v_range=(0, TAU)
        )
        sphere.set_color(YELLOW)
        
        self.play(
            Transform(surface, curved_surface),
            Transform(Group(cone1, cone2), sphere),
            FadeOut(prompt1), # Remove prompt2 from this FadeOut call
            FadeOut(prompt2)  # Add a separate FadeOut call for prompt2
        )
        
        curved_prompt1 = Tex("General Relativity").to_corner(UP + RIGHT)
        curved_prompt2 = MathTex(r"G_{\mu\nu} + g_{\mu\nu}\Lambda = T_{\mu\nu}").next_to(curved_prompt1, DOWN)
        
        self.add_fixed_in_frame_mobjects(curved_prompt1)
        self.add_fixed_in_frame_mobjects(curved_prompt2)
        
        
        # add camera rotation animation
        self.begin_ambient_camera_rotation(rate=0.1)
        self.play(Write(curved_prompt1), FadeIn(curved_prompt2))
        self.wait(5)
       

        
#------------------------------------------------------------------------------
# 5th Part
#------------------------------------------------------------------------------ 
          
class QuantumMechanics(Scene):
    def construct(self):
        # Define the equations
        eq1 = MathTex(r"i\hbar\frac{\partial}{\partial t}\psi(\mathbf{r},t)=-\frac{\hbar^{2}}{2m}\nabla^{2}\psi(\mathbf{r},t)").scale(1)
        eq1[0][6].set_color(BLUE)
        eq1[0][2:6].set_color(YELLOW)
        eq1[0][21].set_color(BLUE)
        eq1[0][19:21].set_color(YELLOW)
        eq2 = MathTex(r"\left( \frac{1}{c^2}\frac{\partial^2}{\partial t^2}-\nabla^2+m^2c^2 \right)\psi(\mathbf{r},t)=0").scale(1)
        eq2[0][20].set_color(BLUE)
        eq2[0][5:11].set_color(YELLOW)
        eq2[0][12:14].set_color(YELLOW)
        eq3 = MathTex(r"[c] = [\text{space}][\text{time}]^{-1}").scale(0.8)

        # Define the new equations and text
        text1 = Tex("Quantum Mechanics").to_edge(UP*3)
        text2 = Tex("Relativistic Quantum Mechanics").next_to(eq1, DOWN)

        # Position the equations on the screen
        eq1.to_edge(UP*4)
        eq2.next_to(text2, DOWN)
        eq3.next_to(eq2, DOWN)

        # Add the equations and text to the scene
        self.play(
            Write(text1),
            FadeIn(eq1),
            run_time=2,
        )

        self.play(
            Write(text2),
            FadeIn(eq2),
            FadeIn(eq3),
            run_time=2,
        )

        self.wait()  # Wait for the user to proceed
